\section{Methods}
\label{sec:methods}

The proof-of-concept implementation has two components: a back-end web server that is a stand-in for any web application that implements the WATSUP protocol, and an open-source browser extension that sandboxes the login form from the web page and implements the client-side of the WATSUP protocol.

\subsection{Server}

The server is responsible for generating cryptographically secure nonces, encrypting them with users' public keys before sending them to the client, and handling traditional user registration and login once the correct nonces are returned.

To generate the nonce, the server uses Python's \texttt{random} library function \texttt{SystemRandom} which is designed for cryptographic use. The function generates random numbers from information seeded by the operating system. Since the server runs on a UNIX-like operating system, \texttt{SystemRandom} queries \texttt{/dev/urandom} \cite{Python:2017:SystemRandom, Python:2017:urandom}.

To generate the RSA key pair the servers uses \texttt{cryptography}, an open-source Python package developed by the Python Cryptographic Authority \cite{PCA:2017}. The package primarily delegates to "backends" such as OpenSSL and CommonCrypto for the actual for platform-specific cryptographic algorithm implementations. The server uses the SHA-1 hash function for optimal asymmetric encryption padding; SHA-1 is acceptable here because adding padding does not hide sensitive information.

The back-end is written in Python 2.7 and uses the Flask web framework. The server is an instance of Gunicorn, a Python WSGI HTTP server. The server runs on a Heroku instance running Ubuntu 14.04.

\subsection{Client}

The client is implemented as a Google Chrome extension and therefore written in JavaScript, HTML, and CSS. While some portions of the code are Chrome-specific, other modern browsers provide the same functionality through similar APIs, and the codebase could be modified to support multiple browsers.

Importantly, Chrome sandboxes all browser extensions to prevent malicious websites from accessing privileged, extension-only operations; the concept is called the Content Security Policy \cite{Google:2017:contentSecurityPolicy}. The WATSUP client utilizes this security policy to keep user passwords safe. No other JavaScript program can access the extension's JavaScript program or HTML, both which would contain references to the user’s plaintext password.

For the protocol, first, the extension reads the username and password from their input fields and the hostname from Chrome's tabs API \cite{Google:2017:tabs}. Then the program produces a “salt” by separately hashing the username and hostname with SHA-256, and then rehashes the combination of these two hashes. This "salt" is used for generating a cryptographic key. While this information is deterministically generated, it still serves the purpose of a salt by preventing against rainbow table attacks. Next, the extension generates a cryptographic key from the base password and the salt. It uses Password-Based Key Derivation Function 2 (PBKDF2) for 1000 iterations using SHA-256 and the salt to generate 256 bits. This added computation is called "key stretching" and makes the password more difficult to crack.

Finally, the program generates the RSA key pair. The generated bits are used to seed an ARC4 PRNG, which is used to generate an RSA key, as provided by \texttt{cryptico} \cite{Terrell:2017}.

Upon user registration, the username and public key are sent to the server. Upon user login, the user sends the username to request a nonce. The server responds with a server-generated nonce, encrypted with the user's registered public key. The extension decrypts the nonce with the user's private key. The decrypted nonce is then sent to the server. Since the key pair is deterministically generated, the extension re-generates them upon every login. This ensures that the user's actual password is never saved or sent.

The code for both the server and client are open source and available here: \url{https://github.com/watsup-protocol}.

\subsection{Deployment}

Deployment of new technologies and protocols to the internet can be a complicated process, and adoption tends to be slow and spotty. We believe the first step would be to recruit a major browser to implement client-side WATSUP, while providing open source browser plugins for all major browsers. Then, we could recruit some major websites and web frameworks to adopt WATSUP. Due to the minimal work required to implement server-side WATSUP, and cross-compatibility with existing login services, any web service should be able to provide the service with ease.